[
    {
        "category": "Arrays",
        "problems": [
            {
                "problem_name": "Wiggle Sort II",
                "problem_text": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3].... You may assume the input array always has a valid answer.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Shortest Unsorted Continuous Subarray",
                "problem_text": "Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order. Return the shortest such subarray and output its length.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Minimum Moves to Equal Array Elements II",
                "problem_text": "Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal. In one move, you can increment or decrement an element of the array by 1. Test cases are designed so that the answer will fit in a 32-bit integer.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Find First and Last Position of Element in Sorted Array",
                "problem_text": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Maximum Gap",
                "problem_text": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0. You must write an algorithm that runs in linear time and uses linear extra space.",
                "problem_difficulty": "Hard"
            }
        ]
    },
    {
        "category": "Stack",
        "problems": [
            {
                "problem_name": "Implement Stack using Queues",
                "problem_text": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: Notes:",
                "problem_difficulty": "Easy"
            },
            {
                "problem_name": "Implement Queue using Stacks",
                "problem_text": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: Notes:",
                "problem_difficulty": "Easy"
            },
            {
                "problem_name": "Min Stack",
                "problem_text": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class:",
                "problem_difficulty": "Easy"
            },
            {
                "problem_name": "Triangle",
                "problem_text": "Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "LRU Cache",
                "problem_text": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: The functions\u00a0get\u00a0and\u00a0put\u00a0must each run in O(1) average time complexity.",
                "problem_difficulty": "Medium"
            }
        ]
    },
    {
        "category": "Queue",
        "problems": [
            {
                "problem_name": "Implement Queue using Stacks",
                "problem_text": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: Notes:",
                "problem_difficulty": "Easy"
            },
            {
                "problem_name": "Implement Stack using Queues",
                "problem_text": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: Notes:",
                "problem_difficulty": "Easy"
            },
            {
                "problem_name": "Binary Tree Level Order Traversal",
                "problem_text": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Sliding Window Maximum",
                "problem_text": "You are given an array of integers\u00a0nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",
                "problem_difficulty": "Hard"
            },
            {
                "problem_name": "Binary Tree Level Order Traversal II",
                "problem_text": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
                "problem_difficulty": "Medium"
            }
        ]
    },
    {
        "category": "Tree",
        "problems": [
            {
                "problem_name": "Binary Tree Right Side View",
                "problem_text": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Binary Tree Level Order Traversal",
                "problem_text": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Unique Binary Search Trees II",
                "problem_text": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Binary Tree Level Order Traversal II",
                "problem_text": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Construct Binary Tree from Preorder and Inorder Traversal",
                "problem_text": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
                "problem_difficulty": "Medium"
            }
        ]
    },
    {
        "category": "Graph",
        "problems": [
            {
                "problem_name": "Binary Tree Zigzag Level Order Traversal",
                "problem_text": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Binary Tree Level Order Traversal II",
                "problem_text": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Binary Tree Level Order Traversal",
                "problem_text": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Construct Binary Tree from Inorder and Postorder Traversal",
                "problem_text": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Binary Tree Inorder Traversal",
                "problem_text": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
                "problem_difficulty": "Easy"
            }
        ]
    },
    {
        "category": "Hashing",
        "problems": [
            {
                "problem_name": "Map Sum Pairs",
                "problem_text": "Design a map that allows you to do the following: Implement the MapSum class:",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Ugly Number II",
                "problem_text": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return the nth ugly number.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Palindrome Pairs",
                "problem_text": "Given a list of unique words, return all the pairs of the\u00a0distinct indices (i, j) in the given list, so that the concatenation of the two words\u00a0words[i] + words[j] is a palindrome.",
                "problem_difficulty": "Hard"
            },
            {
                "problem_name": "Intersection of Two Arrays",
                "problem_text": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.",
                "problem_difficulty": "Easy"
            },
            {
                "problem_name": "Find the Difference",
                "problem_text": "You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t.",
                "problem_difficulty": "Easy"
            }
        ]
    },
    {
        "category": "Sorting Algorithms",
        "problems": [
            {
                "problem_name": "Sort Characters By Frequency",
                "problem_text": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Sort List",
                "problem_text": "Given the head of a linked list, return the list after sorting it in ascending order.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Insertion Sort List",
                "problem_text": "Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head. The steps of the insertion sort algorithm: The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Merge k Sorted Lists",
                "problem_text": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
                "problem_difficulty": "Hard"
            },
            {
                "problem_name": "Top K Frequent Words",
                "problem_text": "Given an array of strings words and an integer k, return the k most frequent strings. Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.",
                "problem_difficulty": "Medium"
            }
        ]
    },
    {
        "category": "Dynamic Programming",
        "problems": [
            {
                "problem_name": "Palindrome Linked List",
                "problem_text": "Given the head of a singly linked list, return true if it is a palindrome.",
                "problem_difficulty": "Easy"
            },
            {
                "problem_name": "Longest Palindromic Substring",
                "problem_text": "Given a string s, return the longest palindromic substring in s.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "Unique Binary Search Trees II",
                "problem_text": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.",
                "problem_difficulty": "Medium"
            },
            {
                "problem_name": "All O`one Data Structure",
                "problem_text": "Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts. Implement the AllOne class:",
                "problem_difficulty": "Hard"
            },
            {
                "problem_name": "Mini Parser",
                "problem_text": "Given a string s represents the serialization of a nested list, implement a parser to deserialize it and return the deserialized NestedInteger. Each element is either an integer or a list whose elements may also be integers or other lists.",
                "problem_difficulty": "Medium"
            }
        ]
    }
]